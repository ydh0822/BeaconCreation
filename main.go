package main

import (
	"fmt"
	"log"
	"os"
	"os/exec"
	"time"

	"github.com/google/gopacket/pcap"
)

func main() {
	BEC()
}

func Turnonmon(name string) {
	ExcuteCMD("sudo", "ifconfig", name, "down")
	fmt.Println(name + " is down")
	ExcuteCMD("sudo", "iwconfig", name, "mode", "monitor")
	fmt.Println(name + " turn monitor mode")
	ExcuteCMD("sudo", "ifconfig", name, "up")
	fmt.Println(name + " is up \n")
}

func ExcuteCMD(script string, arg ...string) {
	cmd := exec.Command(script, arg...)
	output, err := cmd.CombinedOutput()
	if err != nil {
		fmt.Println(string(output))
		fmt.Println((err))
	} else {
		fmt.Println(string(output))
	}
}

type H4uN_packet struct {
	dumpdata    [3]uint64 // 몰라 버려
	Signiture   uint32    //0x00800000 radiotap 시그니처
	dumpdata2   [30]byte
	name_length uint   //61번째 바이트가 이름 길이 플래그
	name        []byte //이름 데이터 SSID
	name_footer uint32 //0x01, 0x08, 0x82, 0x84 이름 시그니처
}

const (
	defaultSnapLen = 262144
)

func BEC() {
	fmt.Println("__BEC Start__")

	var name string
	fmt.Printf("Input Wireless interface Name : ")
	fmt.Scanln(&name)

	handle, err := pcap.OpenLive(name, defaultSnapLen, true, pcap.BlockForever)
	if err != nil {
		log.Fatal(err)
		os.Exit(-1)
	}
	defer handle.Close()

	Turnonmon(name) // turn on monitor mode

	// basePacket1 := []byte{0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0xa0, 0x00, 0x08, 0x00, 0x00, 0x00, 0x02, 0x71, 0x09,
	// 	0xa0, 0x00, 0xc9, 0x00, 0x00, 0x00, 0xc9, 0x00, 0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x04,
	// 	0xd4, 0xc4, 0x51, 0xd3, 0x68, 0x04, 0xd4, 0xc4, 0x51, 0xd3, 0x68, 0x00, 0xba, 0x89, 0x71, 0x1c, 0x61, 0x08, 0x00,
	// 	0x00, 0x00, 0x64, 0x00, 0x11, 0x04, 0x00, 0x07, 0x66, 0x75, 0x63, 0x6b, 0x79, 0x6f, 0x75, 0x01, 0x08, 0x82, 0x84,
	// 	0x8b, 0x96, 0x24, 0x30, 0x48, 0x6c, 0x03, 0x01, 0x03, 0x05, 0x04,
	// 	0x00, 0x03, 0x00, 0x00, 0x07, 0x06, 0x4b, 0x52, 0x04, 0x01, 0x0d, 0x14, 0x23, 0x02, 0x16, 0x00, 0x2a, 0x01, 0x02,
	// 	0x32, 0x04, 0x0c, 0x12, 0x18, 0x60, 0x30, 0x14, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x04, 0x01, 0x00, 0x00, 0x0f, 0xac,
	// 	0x04, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x02, 0x8c, 0x00, 0x0b, 0x05, 0x00, 0x00, 0x4c, 0x00, 0x00, 0x42, 0x01, 0x00,
	// 	0x2d, 0x1a, 0xef, 0x11, 0x17, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3d, 0x16, 0x03, 0x00, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00,
	// 	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x4a, 0x0e, 0x14, 0x00, 0x0a,
	// 	0x00, 0x2c, 0x01, 0xc8, 0x00, 0x14, 0x00, 0x05, 0x00, 0x19, 0x00, 0x7f, 0x08, 0x05, 0x00, 0x08, 0x00, 0x00, 0x00,
	// 	0x00, 0x40, 0xbf, 0x0c, 0xb1, 0x69, 0x83, 0x0f, 0xaa, 0xff, 0x00, 0x00, 0xaa, 0xff, 0x00, 0x00, 0xc0, 0x05, 0x00,
	// 	0x03, 0x00, 0x00, 0x00, 0xdd, 0x35, 0x00, 0x50, 0xf2, 0x04, 0x10, 0x4a, 0x00, 0x01, 0x10, 0x10, 0x44, 0x00, 0x01,
	// 	0x02, 0x10, 0x47, 0x00, 0x10, 0xbe, 0x6c, 0x8d, 0xc7, 0x3a, 0x1d, 0xd7, 0x2f, 0x91, 0x52, 0x98, 0x16, 0xd2, 0x75,
	// 	0xf1, 0x4e, 0x10, 0x3c, 0x00, 0x01, 0x03, 0x10, 0x49, 0x00, 0x0a, 0x00, 0x37, 0x2a, 0x00, 0x01, 0x20, 0x05, 0x02,
	// 	0x07, 0x84, 0xdd, 0x25, 0xf8, 0x32, 0xe4, 0x01, 0x01, 0x01, 0x02, 0x01, 0x00, 0x03, 0x14, 0x00, 0x48, 0x67, 0x0d,
	// 	0x2f, 0xd6, 0x5f, 0xbe, 0x7b, 0xd5, 0xe5, 0xf7, 0xc8, 0xc3, 0x92, 0x33, 0x5a, 0xed, 0x3b, 0x88, 0x07, 0x04, 0x5a,
	// 	0xed, 0x3b, 0x88, 0xdd, 0x1e, 0x00, 0x90, 0x4c, 0x04, 0x18, 0xbf, 0x0c, 0xb1, 0x69, 0x83, 0x0f, 0xaa, 0xff, 0x00,
	// 	0x00, 0xaa, 0xff, 0x00, 0x00, 0xc0, 0x05, 0x00, 0x03, 0x00, 0x00, 0x00, 0xc3, 0x02, 0x00, 0x02, 0xdd, 0x09, 0x00,
	// 	0x10, 0x18, 0x02, 0x00, 0x00, 0x9c, 0x00, 0x00, 0xdd, 0x18, 0x00, 0x50, 0xf2, 0x02, 0x01, 0x01, 0x84, 0x00, 0x03,
	// 	0xa4, 0x00, 0x00, 0x27, 0xa4, 0x00, 0x00, 0x42, 0x43, 0x5e, 0x00, 0x62, 0x32, 0x2f, 0x00, 0xdd, 0x07, 0x50, 0x6f,
	// 	0x9a, 0x16, 0x01, 0x01, 0x00}

	basePacket := []byte{0x00, 0x00, 0x18, 0x00, 0x2e, 0x40, 0x00, 0xa0, 0x20, 0x08, 0x00, 0x00, 0x00, 0x02, 0x7b, 0x09, 0xa0, 0x00, 0xc7, 0x00, 0x00, 0x00, 0xc7, 0x00, 0x80, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x70, 0x5d, 0xcc, 0xe8, 0x69, 0xa6, 0x70, 0x5d, 0xcc, 0xe8, 0x69, 0xa6, 0x70, 0x8d, 0x1c, 0x80, 0xf5, 0xee, 0x44, 0x01, 0x00, 0x00, 0x64, 0x00, 0x11, 0x0c, 0x00, 0x07, 0x66, 0x75, 0x63, 0x6b, 0x79, 0x6f, 0x75, 0x01, 0x08, 0x82, 0x84, 0x8b, 0x96, 0x0c, 0x12, 0x18, 0x24, 0x03, 0x01, 0x0a, 0x05, 0x04, 0x01, 0x03, 0x00, 0x02, 0x2a, 0x01, 0x04, 0x32, 0x04, 0x30, 0x48, 0x60, 0x6c, 0x0b, 0x05, 0x00, 0x00, 0x2b, 0x00, 0x00, 0x2d, 0x1a, 0xee, 0x19, 0x1e, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
		00, 0x18, 0x04, 0x81, 0x08, 0x00, 0x3d, 0x16, 0x0a, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x14, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x04, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x04, 0x01, 0x00, 0x00, 0x0f, 0xac, 0x02, 0x00, 0x00, 0xdd, 0x18, 0x00, 0x50, 0xf2, 0x02, 0x01, 0x01, 0x80, 0x00, 0x03, 0xa4, 0x00, 0x00, 0x27, 0xa4, 0x00, 0x00, 0x42, 0x43, 0x5e, 0x00, 0x62, 0x32, 0x2f, 0x00, 0xdd, 0x06, 0x00, 0xe0, 0x4c, 0x02, 0x01, 0x60, 0xdd, 0x4f, 0x00, 0x50, 0xf2, 0x04, 0x10, 0x4a, 0x00, 0x01, 0x10, 0x10, 0x44, 0x00, 0x01, 0x02, 0x10, 0x54, 0x00, 0x08, 0x00, 0x06, 0x00, 0x50, 0xf2, 0x04, 0x00, 0x01, 0x10, 0x11, 0x00, 0x08, 0x4d, 0x45, 0x53, 0x48, 0x5f, 0x32, 0x5f, 0x32, 0x10, 0x08,
		00, 0x02, 0x00, 0x80, 0x10, 0x47, 0x00, 0x10, 0x63, 0x04, 0x12, 0x53, 0x10, 0x19, 0x20, 0x06, 0x12, 0x28, 0x70, 0x5d, 0xcc, 0xe8, 0x69, 0xa4, 0x10, 0x3c, 0x00, 0x01, 0x03, 0x10, 0x49, 0x00, 0x06, 0x00, 0x37, 0x2a, 0x00, 0x01, 0x20, 0x7f, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}

	// var radiotap layers.RadioTap      // radiotap 설정
	// var beacon layers.Dot11MgmtBeacon // 비콘 선언
	// beacon.Timestamp = uint64(time.Now().Unix())
	// beacon.Interval = 100
	// beacon.Contents = []byte{0x03, 0x30, 0x20, 0x10}
	// beacon.Dot11Mgmt.Payload = []byte{0xff, 0xdd, 0xaa, 0xbb}

	// //radiotap 필드 설정
	// radiotap.Present = layers.RadioTapPresentTSFT | layers.RadioTapPresentFlags | layers.RadioTapPresentRate
	// radiotap.TSFT = uint64(time.Now().UnixNano() / 1000)
	// radiotap.Rate = 2

	// packet := gopacket.NewSerializeBuffer()
	// opts := gopacket.SerializeOptions{FixLengths: true, ComputeChecksums: true}
	// for {
	// 	err := gopacket.SerializeLayers(packet, opts, &beacon)
	// 	if err != nil {
	// 		log.Fatal(err)
	// 	}

	// 	handle.WritePacketData(basePacket)
	// 	time.Sleep(time.Millisecond * 50)
	// }

	for {
		handle.WritePacketData(basePacket)
		time.Sleep(time.Millisecond * 50)
	}
}
